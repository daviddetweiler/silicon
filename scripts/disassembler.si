1 var: queried-word

fn: reverse-find-raw
    ( word -- entry? )

	queried-word store
	dictionary load

	while
		copy 0~=
	do
		copy entry-data-ptr
		queried-word load
		= if
			return
		end-if

		load
	end-while

	drop 0
end-fn

fn: reverse-find
    ( word -- name? length? )
    reverse-find-raw
    copy 0~= if
        entry-name
    else
        0
    end-if
end-fn

fn: show-pointer
    ( ptr-value -- )

    copy reverse-find
    copy 0~= if
        print-yellow nl drop
    else
        drop-pair hex print-u# nl
    end-if
end-fn

fn: show-instr
    ( thread-ptr -- )

    copy hex print-u# tabstop
    load show-pointer
end-fn

find: return const: return-word

s" Quoted word not found" string: not-found

fn: quote:
    ( -- )

    find:
    copy 0= if
        not-found print-red nl
        drop
        soft-fault
    end-if

    assemble-literal
    assemble
end-fn immediate

s" Not a threaded word" string: not-threaded

1 var: this-entry

fn: is-final
    ( thread-ptr -- final? )
    
    copy assembly-arena-top load = push
    load this-entry load =
    pop |
end-fn

\ DANGER: this will run straight off the end as-is if you start it in the middle of a threaded word
fn: disasm-raw
    ( thread-ptr -- )

    while
        copy is-final ~
    do
        copy show-instr
        cell-size +
    end-while

    drop
end-fn

fn: disasm-word
    ( word -- )

    copy load
    ptr-invoke-thread ~= if
        drop
        not-threaded print-red nl
        return
    end-if

    copy reverse-find-raw this-entry store

    cell-size + disasm-raw
end-fn

fn: disasm:
    ( -- )
    find:

    copy 0= if
        not-found print-red nl
        drop
        return
    end-if

    disasm-word
end-fn
