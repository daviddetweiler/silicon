create quote dictionary store immediate
assemble-thread
get-word get-word	assemble
get-word assemble	assemble
assemble-return

flush-line	`define` acts to create a new word at the tip of the dictionary, with subsequent `assemble` instructions
flush-line	appending to its definition

create define dictionary store
assemble-thread
quote create
quote dictionary
quote store
assemble-return

create ] dictionary store immediate
assemble-thread
assemble-literal -1 assemble
quote is-assembling
quote store
assemble-return

create [ dictionary store immediate
assemble-thread
quote 0				flush-line	`quote 0` only works because `0` is in the dictionary, but -1 isn't
quote is-assembling
quote store
assemble-return

flush-line	`fn` defines a new word, specifies it as a thread, and enables assembly mode in the interpreter

define fn
assemble-thread
quote ]
quote create
quote partial-definition
quote store
quote assemble-thread
assemble-return

flush-line	`end-fn` terminates the current definition with a `return`, and disables assembly mode in the interpreter

define end-fn immediate
assemble-thread
quote partial-definition
quote load
quote dictionary
quote store
quote 0
quote partial-definition
quote store
quote assemble-return
quote [
assemble-return

flush-line	Now we use `fn`-`end-fn` to define `\` as an alias for `flush-line`, for nicer comment syntax
flush-line	Note that this definition is marked `immediate`, so that it even works in the middle of a definition
flush-line	Otherwise `\` would be simply assembled into the definition, with unusual results upon execution

fn \
	flush-line
end-fn immediate

\ value --
\
\ `const` merely defines a word with a reference to `invoke_constant` in the kernel, and appends the actual constant
\ value from the data stack
fn const
	define
	assemble-constant assemble
end-fn

\ -- patch-addr
\
\ One of the neat bits of TILs is that control flow constructs are themselves just words, and can be defined as such.
\ To function, they are tagged with `immediate`, which causes them to be executed at definition time when used, and as
\ such are able to modify the in-progress definition.
\
\ `if` works by appending the `~ branch <target>` sequence to the definition, leaving the address of `<target>` on the
\ stack to be patched by the corresponding `end-if`. As such, the final, assembled definition will branch past the
\ wrapped code if the top of the stack is zero, and fall through otherwise.
fn if
	[ assemble-literal ] ~ assemble
	assemble-branch
	here
	0 assemble
end-fn immediate

\ patch-addr --
\
\ `end-if` expects to find the patch address left by the corresponding `if` on the stack, and uses it compute and patch
\ in the true branch target.
fn end-if
	here over cell-size + - swap store
end-fn immediate

\ And here we see example uses of `const` to define `false` as 0 and `true` as ~0, or -1 in signed representation.
0		const false
false ~	const true

\ --
fn :
	fn
end-fn

\ --
\
\ The use of `quote` here is needed, since `end-fn` was tagged `immediate` and would be immediately executed if directly
\ referenced, instead of being assembled in, as intended.
fn ;
	quote end-fn
end-fn immediate

\ condition --
: v?
	if
		version
	end-if
;

\ -- target
\
\ For a `while <condition> do <body> end-while` construct, the underlying code is essentially the condition, followed by
\ an `if`-block guarding the loop body and an additional unconditional jump back to the condition. As such, the only
\ purpose of the `while` word is to record the address of the condition, so that the `end-while` word can assemble the
\ jump back to it.
fn while	here		end-fn immediate

\ -- patch-addr
\
\ As discussed with `while`, the responsibility of `do` is to begin the underlying `if`-block guarding the loop body
fn do		quote if	end-fn immediate

\ target patch-addr --
\
\ Finally, `end-while` assembles the jump back to the condition, while also ending the `if`-block guarding the loop
\ body. A `swap` is needed since at the time it is executed, it expects to see the patch address of the preceding `do`
\ at the top of the stack, but it needs to assemble the backwards jump first, not perform the patch.
fn end-while
	assemble-jump

	swap
	here cell-size +
	- assemble

	quote end-if
end-fn immediate

\ --
fn test
	10
	while
		copy 0 >=
	do
		copy print-# nl
		copy 2 % 0= v?
		1 -
	end-while
	drop
end-fn

\ --
fn recurse
	partial-definition load entry-data-ptr assemble
end-fn immediate

\ patch-addr -- new-patch-addr
\
\ This one's a bit tricky: the idea is to put an uncoditional jump at the end of the preceding if-block, end the
\ if-block, and leaving the address of the jump offset as the new patch address. This way, when `end-if` is executed, it
\ will patch this uncoditional jump, so that upon executing the if-block, execution will jump to just after the
\ `end-if`, and not fall through into the else-block.
fn else
	assemble-jump
	here 0 assemble
	swap quote end-if
end-fn immediate

\ depth --
fn recursion-test
	copy 0~=
	if
		copy print-# nl
		1 - recurse
	else
		drop
	end-if
end-fn
