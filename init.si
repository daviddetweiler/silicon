CREATE: ASSEMBLE-WORD: DICTIONARY STORE IMMEDIATE
ASSEMBLE-INVOKE-THREAD
GET-WORD: GET-WORD: ASSEMBLE
GET-WORD: ASSEMBLE ASSEMBLE
ASSEMBLE-RETURN

CREATE: \ DICTIONARY STORE IMMEDIATE
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-WORD: FLUSH-LINE
ASSEMBLE-RETURN

\ `DEFINE:` ACTS TO CREATE A NEW WORD AT THE TIP OF THE DICTIONARY, WITH SUBSEQUENT `ASSEMBLE` INSTRUCTIONS
\ APPENDING TO ITS DEFINITION
CREATE: DEFINE: DICTIONARY STORE
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-WORD: CREATE:
ASSEMBLE-WORD: DICTIONARY
ASSEMBLE-WORD: STORE
ASSEMBLE-RETURN

DEFINE: [ IMMEDIATE
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-WORD: 0						\ `ASSEMBLE-WORD: 0` ONLY WORKS BECAUSE `0` IS IN THE DICTIONARY
ASSEMBLE-WORD: IS-ASSEMBLING
ASSEMBLE-WORD: STORE
ASSEMBLE-RETURN

DEFINE: ]
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-LITERAL -1 ASSEMBLE
ASSEMBLE-WORD: IS-ASSEMBLING
ASSEMBLE-WORD: STORE
ASSEMBLE-RETURN

\ `END-FN` TERMINATES THE CURRENT DEFINITION WITH A `RETURN`, AND DISABLES ASSEMBLY MODE IN THE INTERPRETER

DEFINE: END-FN IMMEDIATE
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-WORD: CURRENT-DEFINITION
ASSEMBLE-WORD: LOAD
ASSEMBLE-WORD: DICTIONARY
ASSEMBLE-WORD: STORE
ASSEMBLE-WORD: 0
ASSEMBLE-WORD: CURRENT-DEFINITION
ASSEMBLE-WORD: STORE
ASSEMBLE-WORD: ASSEMBLE-RETURN
ASSEMBLE-WORD: [
ASSEMBLE-RETURN

\ `FN:` DEFINES A NEW WORD, SPECIFIES IT AS A THREAD, AND ENABLES ASSEMBLY MODE IN THE INTERPRETER
DEFINE: FN:
ASSEMBLE-INVOKE-THREAD
ASSEMBLE-WORD: ]
ASSEMBLE-WORD: CREATE:
ASSEMBLE-WORD: CURRENT-DEFINITION
ASSEMBLE-WORD: STORE
ASSEMBLE-WORD: ASSEMBLE-INVOKE-THREAD
ASSEMBLE-RETURN

\ VALUE --
\
\ `CONST:` MERELY DEFINES A WORD WITH A REFERENCE TO `INVOKE_CONSTANT` IN THE KERNEL, AND APPENDS THE ACTUAL CONSTANT
\ VALUE FROM THE DATA STACK
FN: CONST:
	DEFINE:
	ASSEMBLE-INVOKE-CONSTANT ASSEMBLE
END-FN

\ -- PATCH-ADDR
\
\ ONE OF THE NEAT BITS OF TILS IS THAT CONTROL FLOW CONSTRUCTS ARE THEMSELVES JUST WORDS, AND CAN BE DEFINED AS SUCH.
\ TO FUNCTION, THEY ARE TAGGED WITH `IMMEDIATE`, WHICH CAUSES THEM TO BE EXECUTED AT DEFINITION TIME WHEN USED, AND AS
\ SUCH ARE ABLE TO MODIFY THE IN-PROGRESS DEFINITION.
\
\ `IF` WORKS BY APPENDING THE `~ BRANCH <TARGET>` SEQUENCE TO THE DEFINITION, LEAVING THE ADDRESS OF `<TARGET>` ON THE
\ STACK TO BE PATCHED BY THE CORRESPONDING `END-IF`. AS SUCH, THE FINAL, ASSEMBLED DEFINITION WILL BRANCH PAST THE
\ WRAPPED CODE IF THE TOP OF THE STACK IS ZERO, AND FALL THROUGH OTHERWISE.
FN: IF
	[ ASSEMBLE-LITERAL ] ~ ASSEMBLE
	ASSEMBLE-BRANCH
	ASSEMBLY-PTR
	0 ASSEMBLE
END-FN IMMEDIATE

\ PATCH-ADDR --
\
\ `END-IF` EXPECTS TO FIND THE PATCH ADDRESS LEFT BY THE CORRESPONDING `IF` ON THE STACK, AND USES IT COMPUTE AND PATCH
\ IN THE TRUE BRANCH TARGET.
FN: END-IF
	ASSEMBLY-PTR OVER CELL-SIZE + - SWAP STORE
END-FN IMMEDIATE

\ AND HERE WE SEE AN EXAMPLE USE OF `CONST:` TO DEFINE BOOLEAN CONSTANTS
0 CONST: FALSE
-1 CONST: TRUE

\ -- TARGET
\
\ FOR A `WHILE <CONDITION> DO <BODY> END-WHILE` CONSTRUCT, THE UNDERLYING CODE IS ESSENTIALLY THE CONDITION, FOLLOWED BY
\ AN `IF`-BLOCK GUARDING THE LOOP BODY AND AN ADDITIONAL UNCONDITIONAL JUMP BACK TO THE CONDITION. AS SUCH, THE ONLY
\ PURPOSE OF THE `WHILE` WORD IS TO RECORD THE ADDRESS OF THE CONDITION, SO THAT THE `END-WHILE` WORD CAN ASSEMBLE THE
\ JUMP BACK TO IT.
FN: WHILE ASSEMBLY-PTR END-FN IMMEDIATE

\ -- PATCH-ADDR
\
\ AS DISCUSSED WITH `WHILE`, THE RESPONSIBILITY OF `DO` IS TO BEGIN THE UNDERLYING `IF`-BLOCK GUARDING THE LOOP BODY
FN: DO ASSEMBLE-WORD: IF END-FN IMMEDIATE

\ TARGET PATCH-ADDR --
\
\ FINALLY, `END-WHILE` ASSEMBLES THE JUMP BACK TO THE CONDITION, WHILE ALSO ENDING THE `IF`-BLOCK GUARDING THE LOOP
\ BODY. A `SWAP` IS NEEDED SINCE AT THE TIME IT IS EXECUTED, IT EXPECTS TO SEE THE PATCH ADDRESS OF THE PRECEDING `DO`
\ AT THE TOP OF THE STACK, BUT IT NEEDS TO ASSEMBLE THE BACKWARDS JUMP FIRST, NOT PERFORM THE PATCH.
FN: END-WHILE
	ASSEMBLE-JUMP

	SWAP
	ASSEMBLY-PTR CELL-SIZE +
	- ASSEMBLE

	ASSEMBLE-WORD: END-IF
END-FN IMMEDIATE

\ --
FN: RECURSE
	CURRENT-DEFINITION LOAD ENTRY-DATA-PTR ASSEMBLE
END-FN IMMEDIATE

\ PATCH-ADDR -- NEW-PATCH-ADDR
\
\ THIS ONE'S A BIT TRICKY: THE IDEA IS TO PUT AN UNCODITIONAL JUMP AT THE END OF THE PRECEDING IF-BLOCK, END THE
\ IF-BLOCK, AND LEAVING THE ADDRESS OF THE JUMP OFFSET AS THE NEW PATCH ADDRESS. THIS WAY, WHEN `END-IF` IS EXECUTED, IT
\ WILL PATCH THIS UNCODITIONAL JUMP, SO THAT UPON EXECUTING THE IF-BLOCK, EXECUTION WILL JUMP TO JUST AFTER THE
\ `END-IF`, AND NOT FALL THROUGH INTO THE ELSE-BLOCK.
FN: ELSE
	ASSEMBLE-JUMP
	ASSEMBLY-PTR 0 ASSEMBLE
	SWAP ASSEMBLE-WORD: END-IF
END-FN IMMEDIATE

\ PTR -- IN-BOUNDS?
FN: IN-LINE-BOUNDS?
	LINE-START LOAD
	-
	LINE-SIZE LOAD
	<
END-FN

\ -- CODE
\
\ PUSHES THE FIRST CHARACTER AFTER THE FIRST SPACE CHARACTER, ADVANCING THE LINE POINTER TO JUST AFTER IT
FN: CHAR:
	CURRENT-WORD LOAD-PAIR +	\ WE NOW HAVE A POINTER TO THE REST OF THE LINE AFTER OURSELVES
	1 + 						\ SKIP THE INITIAL SPACE
	COPY IN-LINE-BOUNDS?
	IF
		COPY LOAD-BYTE STASH
		1 +
		CURRENT-WORD LOAD -
		CURRENT-WORD STORE-2ND
		UNSTASH
	ELSE
		DROP 0 FLUSH-LINE
	END-IF
END-FN

CHAR: " CONST: DQUOTE-CHAR

\ -- STRING? LENGTH
\
\ FAILS IF THERE IS NO TERMINATING `"` BEFORE THE END OF THE LINE. PLEASE NOTE THAT IT IGNORES THE INITIAL SPACE.
FN: S"
	CURRENT-WORD LOAD-PAIR +	\ WE NOW HAVE A POINTER TO THE REST OF THE LINE AFTER OURSELVES
	1 + COPY					\ SKIP THE INITIAL SPACE
	WHILE
		COPY IN-LINE-BOUNDS?
		OVER LOAD-BYTE DQUOTE-CHAR ~=
		&
	DO
		1 +
	END-WHILE

	\ BY THIS POINT WE ONLY HAVE A POINTER ON THE STACK, WHICH EITHER POINTS TO THE END OF THE LINE, OR THE `"`
	COPY IN-LINE-BOUNDS?
	IF
		COPY CURRENT-WORD LOAD - 1 +	\ LENGTH OF THE SKIPPED PORTION
		CURRENT-WORD STORE-2ND			\ STORE THE LENGTH; THE NEXT ACCEPT-WORD WILL START AT THE END OF THE STRING
		OVER -
	ELSE
		\ IF WE DIDN'T FIND THE CLOSING `"` BEFORE THE END OF THE LINE, WE NEED TO DISCARD THE STRING
		DROP
		DROP
		FLUSH-LINE
		0 0
	END-IF
END-FN

\ --
FN: VERSION
	VERSION-STRING PRINT-LINE
END-FN

\ STRING LENGTH -- COMMITTED-STRING LENGTH
FN: STRING
	COPY STASH
	COPY ASSEMBLE-BYTE
	ASSEMBLY-PTR STASH
	ASSEMBLE-STRING
	UNSTASH UNSTASH
END-FN

\ STRING LENGTH --
FN: STRING:
	DEFINE:
	ASSEMBLE-INVOKE-STRING
	STRING DROP-PAIR
END-FN

S"     " STRING: EMPTY-TAG
S" *   " STRING: IMMEDIATE-TAG

\ N-CELLS --
FN: VAR:
	DEFINE:
	ASSEMBLE-INVOKE-VARIABLE
	CELL-SIZE * ARENA-ALLOCATE
END-FN

CHAR: 0						CONST:	DIGIT-0
8 4 *						CONST:	FORMATTED-DECIMAL-SIZE
FORMATTED-DECIMAL-SIZE 8 /	VAR:	FORMATTED-DECIMAL

\ N --
FN: PRINT-U#
	COPY 0=
	IF
		DROP
		DIGIT-0 FORMATTED-DECIMAL STORE-BYTE
		FORMATTED-DECIMAL 1 PRINT
		RETURN
	END-IF

	FORMATTED-DECIMAL
	FORMATTED-DECIMAL-SIZE +
	COPY STASH STASH

	WHILE
		COPY 0~=
	DO
		COPY 10 U%
		DIGIT-0 + UNSTASH 1 - SWAP OVER STORE-BYTE STASH
		10 U/
	END-WHILE

	DROP
	UNSTASH
	UNSTASH
	OVER - PRINT
END-FN

S" -" STRING: NEGATIVE

\ N --
FN: PRINT-#
	COPY 0>
	IF
		NEGATIVE PRINT
		0- PRINT-U#
	ELSE
		PRINT-U#
	END-IF
END-FN

\ STRING LENGTH --
FN: PRINT-YELLOW
	SEQ-YELLOW PRINT
	PRINT
	SEQ-DEFAULT PRINT
END-FN

\ STRING LENGTH --
FN: PRINT-RED
	SEQ-RED PRINT
	PRINT
	SEQ-DEFAULT PRINT
END-FN

\ DICT-PTR --
FN: VOCABULARY
	NL

	WHILE
		COPY 0~=
	DO
		COPY ENTRY-METADATA
		IF
			IMMEDIATE-TAG
		ELSE
			EMPTY-TAG
		END-IF

		PRINT-RED PRINT-YELLOW NL

		LOAD
	END-WHILE

	DROP NL
END-FN

S"  BYTES OF CODE"		STRING: BYTES-OF-CODE
S"  BYTES OF DATA"		STRING: BYTES-OF-DATA
S"  BYTES OF VARIABLES"	STRING: BYTES-OF-VARIABLES
S" 	"					STRING: TAB

\ --
FN: INFORMATION
	VERSION
	TEXT-SIZE PRINT-U# TAB PRINT BYTES-OF-CODE PRINT-LINE
	RDATA-SIZE PRINT-U# TAB PRINT BYTES-OF-DATA PRINT-LINE
	BSS-SIZE PRINT-U# TAB PRINT BYTES-OF-VARIABLES PRINT-LINE
	DICTIONARY LOAD VOCABULARY
END-FN

FN: CORE-DICT
	[ CURRENT-DEFINITION LOAD ASSEMBLE-LITERAL ASSEMBLE ]
END-FN

VERSION NL
